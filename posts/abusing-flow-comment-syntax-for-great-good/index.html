<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link rel="shortcut icon" href="/favicon.png" sizes="16x16" />
<link rel="shortcut icon" href="/favicon-256.png" sizes="256x256" />
<link rel="apple touch icon" href="/favicon-256.png" />
<title>Abusing Flow comment syntax for great good</title>
<style>/*! normalize.css v4.1.1 | MIT License | github.com/necolas/normalize.css */
html{font-family:sans-serif;line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress,sub,sup{vertical-align:baseline}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline dotted}b,strong{font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,hr,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{color:inherit;display:table;max-width:100%;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio],legend{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}</style>
<style>p{margin-top:0}</style>
<style>code .comment{color:#6e6e6e}code:not([data-hide-strings]) .string{color:#6e6e6e}code .important{font-style:italic}code .keyword{font-weight:700}code .prompt,code .tt{font-family:monospace}code .prompt{user-select:none}code .property,code .property+.punctuation{font-weight:700}code .tag .tag:first-child{font-weight:700}code .punctuation{font-weight:400}</style>
<style data-aphrodite>._684hqj{font-family:Helvetica, Arial, sans-serif;font-size:16px;color:#121316;line-height:1.5;}._12iqsw5{position:fixed;z-index:-1;top:0px;bottom:0px;width:-webkit-calc(max(400px, 50vw - 420px));width:-moz-calc(max(400px, 50vw - 420px));width:calc(max(400px, 50vw - 420px));left:-webkit-calc(50vw - 420px - max(400px, 50vw - 420px));left:-moz-calc(50vw - 420px - max(400px, 50vw - 420px));left:calc(50vw - 420px - max(400px, 50vw - 420px));background:url(/static/skygradopaque.d6e5e82bc642.jpg), -webkit-linear-gradient(to bottom, #9eabbc 0%, #aebbc3 47%, #c1c0b4 73%, #c3af97 89%, #bd987e 100%);background:url(/static/skygradopaque.d6e5e82bc642.jpg), -moz-linear-gradient(to bottom, #9eabbc 0%, #aebbc3 47%, #c1c0b4 73%, #c3af97 89%, #bd987e 100%);background:url(/static/skygradopaque.d6e5e82bc642.jpg), linear-gradient(to bottom, #9eabbc 0%, #aebbc3 47%, #c1c0b4 73%, #c3af97 89%, #bd987e 100%);background-size:100% 100%;-webkit-mask-image:-webkit-linear-gradient(to right, rgb(0 0 0 / 100%), rgb(0 0 0 / 50%) 25%, transparent);-webkit-mask-image:-moz-linear-gradient(to right, rgb(0 0 0 / 100%), rgb(0 0 0 / 50%) 25%, transparent);-webkit-mask-image:linear-gradient(to right, rgb(0 0 0 / 100%), rgb(0 0 0 / 50%) 25%, transparent);mask-image:-webkit-linear-gradient(to right, rgb(0 0 0 / 100%), rgb(0 0 0 / 50%) 25%, transparent);mask-image:-moz-linear-gradient(to right, rgb(0 0 0 / 100%), rgb(0 0 0 / 50%) 25%, transparent);mask-image:linear-gradient(to right, rgb(0 0 0 / 100%), rgb(0 0 0 / 50%) 25%, transparent);}._1qcuqeh{position:absolute;z-index:-1;top:0px;right:-webkit-calc(50vw + 420px);right:-moz-calc(50vw + 420px);right:calc(50vw + 420px);opacity:0.25;}._37ihjp{border-top:#046375 5px solid;border-bottom:0.5px #cecece solid;margin-bottom:24px;padding-top:10px;padding-bottom:10px;}._tcz2umt{-webkit-box-align:center;-ms-flex-align:center;-webkit-box-pack:justify;-ms-flex-pack:justify;max-width:800px;margin:auto;padding-left:20px;padding-right:20px;display:-webkit-box;display:-moz-box;display:-ms-flexbox;display:-webkit-flex;display:flex;-webkit-justify-content:space-between;justify-content:space-between;-webkit-align-items:center;align-items:center;margin-top:10px;margin-bottom:10px;}._odt2os{font-size:24px;letter-spacing:-0.5px;color:#222;}._1yyogy7{max-width:800px;margin:auto;padding-left:20px;padding-right:20px;}._1gtwn3{color:#6e6e6e;border-top:0.5px #cecece solid;margin-top:24px;padding-top:24px;padding-bottom:24px;}._16597jh{text-decoration:none;color:#0a7f96;}._16597jh:hover{color:#046375;text-decoration:underline;}._16597jh:active{color:#0a7f96;text-decoration:underline;}._1rq9psi{list-style:none;padding-left:0px;margin:0px;}._txtyvv{display:inline;margin-left:20px;}._nqjtz2{margin-top:30px;margin-bottom:10px;font-size:32px;font-weight:normal;}._gy9i19{margin:16px;overflow-x:auto;background:rgba(10,127,150,0.1);border-left:#0a7f96 2px solid;padding:16px;line-height:140%;}._1napz9l{font-family:Helvetica,Arial,sans-serif;}._1ucarsym{font-family:Helvetica,Arial,sans-serif;padding:2px 4px;background:rgba(10,127,150,0.1);white-space:pre-wrap;}._1htp0dj{margin-top:26px;margin-bottom:8px;font-size:24px;font-weight:normal;}</style>
<noscript><style>.yesscript{display:none;}</style></noscript>
</head>
<body style="overflow-y:scroll">
<div id="container"><div class="_684hqj"><div class="_12iqsw5"></div><img class="_1qcuqeh" src="/static/leaves.adfcead73f2e.png" width="226" height="400" alt=""/><header class="_37ihjp"><nav class="_tcz2umt"><a class="_odt2os _16597jh" href="/">Willow Chargin</a><ul class="_1rq9psi"><li class="_txtyvv"><a class="_16597jh" href="/"><svg width="14" height="14" viewBox="0 0 16 16" alt="Home" aria-label="Home"><path fill="currentColor" d="M15.45,7L14,5.551V2c0-0.55-0.45-1-1-1h-1c-0.55,0-1,0.45-1,1v0.553L9,0.555C8.727,0.297,8.477,0,8,0S7.273,0.297,7,0.555  L0.55,7C0.238,7.325,0,7.562,0,8c0,0.563,0.432,1,1,1h1v6c0,0.55,0.45,1,1,1h3v-5c0-0.55,0.45-1,1-1h2c0.55,0,1,0.45,1,1v5h3  c0.55,0,1-0.45,1-1V9h1c0.568,0,1-0.437,1-1C16,7.562,15.762,7.325,15.45,7z"></path></svg></a></li><li class="_txtyvv"><a class="_16597jh" href="/posts/">Posts</a></li></ul></nav></header><article class="_1yyogy7"><div><a style="margin-bottom:10px;margin-top:10px" class="_16597jh" href="/posts"><i>« back to posts</i></a><article><div><h1 class="_nqjtz2">Abusing Flow comment syntax for great good</h1><p><i>2018-05-23</i> <!-- -->·<!-- --> <i><a href="https://github.com/wchargin/wchargin.github.io/blob/source/src/pages/posts/data/abusingFlowComments.js" class="_16597jh">view article source</a></i></p></div><p><a class="_16597jh" href="https://flow.org/">Flow</a> is a static type system for JavaScript. Code written with Flow looks like normal JavaScript with extra type declarations and type annotations:</p><pre class="_gy9i19"><code class="_1napz9l"><span class="token keyword">type</span> ShoppingCartEntry = {productName: string, count: number};
<span class="token keyword">function</span> totalCount(cart: ShoppingCartEntry[]): number {
    <span class="token keyword">const</span> counts: number[] = cart.map((entry) => entry.count);
    <span class="token keyword">return</span> counts.reduce((a, b) => a + b, 0);
}
</code></pre><p>These addenda of course mean that the code is not itself valid JavaScript. Flow provides a preprocessor to strip away these annotations, but also offers an alternative <a class="_16597jh" href="https://flow.org/en/docs/types/comments/">comment syntax</a> in case using a preprocessor would be undesirable for some reason or other:</p><pre class="_gy9i19"><code class="_1napz9l"><span class="token comment">/*:: type ShoppingCartEntry = {productName: string, count: number}; */</span>
<span class="token keyword">function</span> totalCount(cart <span class="token comment">/*: ShoppingCartEntry[] */</span>) <span class="token comment">/*: number */</span> {
    <span class="token keyword">const</span> counts <span class="token comment">/*: number[] */</span> = cart.map((entry) => entry.count);
    <span class="token keyword">return</span> counts.reduce((a, b) => a + b, 0);
}
</code></pre><p>The semantics are simple: any block comment that starts with <code class="_1ucarsym">::</code> (a double colon) is treated as normal Flow code by the Flow parser, and for convenience any block comment that starts with <code class="_1ucarsym">:</code> (a single colon) is treated as normal Flow code that starts with a literal colon, so that type annotations can be written like <code class="_1ucarsym">(17 <span class="token comment">/*: number */</span>)</code> instead of the more awkward <code class="_1ucarsym">(17 <span class="token comment">/*:: : number */</span>)</code>.</p><p>This comment syntax is an entirely reasonable feature that we can abuse to create horrifying, devious contraptions. Sounds like fun!</p><p>(Note: All code in this post works on Flow v0.72. These techniques may well be patched in the future.)</p><h2 class="_1htp0dj">Motivation: Incompleteness</h2><p>Sometimes, we write code that is provably correct in a way that the type checker can’t infer. For instance, suppose that we have an array with elements of type <code class="_1ucarsym">Person | <span class="token keyword">null</span></code> (“either <code class="_1ucarsym">Person</code> or <code class="_1ucarsym"><span class="token keyword">null</span></code>”), where <code class="_1ucarsym">Person</code> is an object type with a string field called <code class="_1ucarsym">name</code>. We want to retrieve the names of all the people in the array, ignoring the <code class="_1ucarsym"><span class="token keyword">null</span></code> elements. In plain JavaScript, we might write something like this:</p><pre class="_gy9i19"><code class="_1napz9l"><span class="token comment">/*:: type Person = {name: string, favoriteColor: string}; */</span>
<span class="token keyword">function</span> peopleNames(maybePeople <span class="token comment">/*: (Person | null)[] */</span>) <span class="token comment">/*: string[] */</span> {
    <span class="token keyword">return</span> maybePeople
        .filter((person) => person !== <span class="token keyword">null</span>)
        .map((person) => person.name);
}
</code></pre><p>A human can look at this code and easily see that it returns a valid list of strings. But Flow can’t, for a fully understandable reason. Flow knows that <code class="_1ucarsym">filter</code> takes an array <code class="_1ucarsym">T[]</code> and a predicate <code class="_1ucarsym">(T) => boolean</code>, and returns a new array <code class="_1ucarsym">T[]</code>. However, Flow doesn’t understand the relationship between the inputs and the output—in particular, that every element in the output satisfies the predicate. So, as far as Flow is concerned, the result of the call to <code class="_1ucarsym">filter</code> might still contain <code class="_1ucarsym"><span class="token keyword">null</span></code> elements, and in that case the expression <code class="_1ucarsym">person.name</code> would indeed be cause for alarm.</p><p>In situations like these, it is tempting to reach for the <code class="_1ucarsym"><span class="token keyword">any</span></code> keyword: this is a magic type that is interconvertible with every type and for which all operations are permitted. In effect, it says that “anything goes” whenever a particular variable is involved. We can write:</p><pre class="_gy9i19"><code class="_1napz9l"><span class="token keyword">function</span> peopleNames(maybePeople: (Person | <span class="token keyword">null</span>)[]): string[] {
    <span class="token keyword">return</span> maybePeople
        .filter((person) => person !== <span class="token keyword">null</span>)
        .map((person) => (person: <span class="token keyword">any</span>).name);  <span class="token comment">// cast through `any`!</span>
}
</code></pre><p>But here we are losing valuable type safety. We lose the ability to catch many potential errors in our code—for instance, a typo like <code class="_1ucarsym">person.nmae</code> would go completely undetected. We want to <em>refine</em> the type information, not throw it away.</p><p>We could give Flow a hint, by explicitly checking that each person in the filtered array is actually not <code class="_1ucarsym"><span class="token keyword">null</span></code>:</p><pre class="_gy9i19"><code class="_1napz9l"><span class="token keyword">function</span> peopleNames(maybePeople: (Person | <span class="token keyword">null</span>)[]): string[] {
    <span class="token keyword">return</span> maybePeople
        .filter((person) => person !== <span class="token keyword">null</span>)
        .map((person) => {
            <span class="token comment">// Explicit assertion just to appease the typechecker.</span>
            <span class="token keyword">if</span> (person === <span class="token keyword">null</span>) {
                <span class="token keyword">throw</span> <span class="token keyword">new</span> Error(<span class="token string">"Unreachable!"</span>);
            }
            <span class="token comment">// If we get here, `person` is non-null, so this next line is fine.</span>
            <span class="token keyword">return</span> person.name;
        });
}
</code></pre><p>Flow is now happy to treat the argument to <code class="_1ucarsym">map</code> as a function taking <code class="_1ucarsym">Person | <span class="token keyword">null</span></code> and returning <code class="_1ucarsym">string</code>, so this code type-checks and runs correctly. But this is not a great solution. Assertions like this make the code more verbose and harder to read, interrupting (ironically) a reader’s flow. Furthermore, writing code in anything other than the most natural way simply to appease tooling of any sort should always be a red flag: tools exist to <em>help</em> programmers, not hinder them, and if the tools are broken then they must be fixed.</p><p>Or: instead of fixing these tools, we can just lie to them.</p><h2 class="_1htp0dj">White lies</h2><p>Suppose that we had access to a function <code class="_1ucarsym">withoutNulls</code> that gave a copy of its input array with all <code class="_1ucarsym"><span class="token keyword">null</span></code> elements removed. In that case, Flow would be satisfied by the following code:</p><pre class="_gy9i19"><code class="_1napz9l"><span class="token keyword">function</span> withoutNulls&lt;T>(xs: (T | <span class="token keyword">null</span>)[]): T[] { <span class="token comment">/* implementation elided */</span> }
<span class="token keyword">function</span> peopleNames(maybePeople: (Person | <span class="token keyword">null</span>)[]): string[] {
    <span class="token keyword">let</span> people = maybePeople.filter((person) => person !== <span class="token keyword">null</span>);
    people = withoutNulls(people);  <span class="token comment">// no-op</span>
    <span class="token keyword">return</span> people.map((person) => person.name);
}
</code></pre><p>Of course, we don’t actually want to call this function, and ideally we don’t even want the function to exist.</p><p>In fact, Flow makes it easy for us to declare that a function exists without providing its implementation, because this is commonly needed to talk about external library functions and the like. We can start with the following:</p><pre class="_gy9i19"><code class="_1napz9l"><span class="token keyword">declare</span> <span class="token keyword">function</span> withoutNulls&lt;T>(xs: (T | <span class="token keyword">null</span>)[]): T[];
<span class="token keyword">function</span> peopleNames(maybePeople: (Person | <span class="token keyword">null</span>)[]): string[] {
    <span class="token keyword">let</span> people = maybePeople.filter((person) => person !== <span class="token keyword">null</span>);
    people = withoutNulls(people);  <span class="token comment">// now fails at runtime: no such function</span>
    <span class="token keyword">return</span> people.map((person) => person.name);
}
</code></pre><p>Now, Flow is still happy, but our code will fail at runtime unless we actually provide an implementation of the <code class="_1ucarsym">withoutNulls</code> function. We need Flow to <em>think</em> that we’re calling this function without actually having to do so.</p><p>Behold:</p><pre class="_gy9i19"><code class="_1napz9l"><span class="token keyword">declare</span> <span class="token keyword">function</span> withoutNulls&lt;T>(xs: (T | <span class="token keyword">null</span>)[]): T[];
<span class="token keyword">function</span> peopleNames(maybePeople: (Person | <span class="token keyword">null</span>)[]): string[] {
    <span class="token keyword">let</span> people = maybePeople.filter((person) => person !== <span class="token keyword">null</span>);
    <span class="token comment">/*:: people = withoutNulls(people); */</span>  <span class="token comment">// ta-da!</span>
    <span class="token keyword">return</span> people.map((person) => person.name);
}
</code></pre><p>The comment syntax was designed to allow including Flow type annotations, declarations, and the like, but nothing stops us from including actual code! As far as Flow is concerned, the middle line of the function is just as real as the other two.</p><p>Now, for something a bit crazier.</p><h2 class="_1htp0dj">Utter fabrications</h2><p>Suppose that we have some code that requires a module of generated code: created at build time, say, or even at runtime. In JavaScript, it is perfectly fine to write</p><pre class="_gy9i19"><code class="_1napz9l"><span class="token keyword">const</span> frobnicateWidgets = require(<span class="token string">"./frobnicateWidgets"</span>);
</code></pre><p>as long as the module is available when the <code class="_1ucarsym">require</code> expression is evaluated. But such an import is of course incompatible with any static analysis. In particular, Flow will yield an error—“Cannot resolve module”—when the module in question has not yet been generated.</p><p>We can’t use exactly the same trick as before, wherein we performed some assertions that only Flow could see. The problem is that Flow knows what <code class="_1ucarsym">require</code> does—it loads a module. If we were in a context where <code class="_1ucarsym">require</code> were a normal function of appropriate type, then this wouldn’t be a problem.</p><p>And we can make it so:</p><pre class="_gy9i19"><code class="_1napz9l"><span class="token keyword">const</span> frobnicateWidgets =
    <span class="token comment">/*:: ((require: any) => */</span> require(<span class="token string">"./frobnicateWidgets"</span>) <span class="token comment">/*:: )() */</span>;
</code></pre><p>Here we see the return of <code class="_1ucarsym"><span class="token keyword">any</span></code>. Within the body of this lambda expression—which only exists in Flow’s eyes!—<code class="_1ucarsym">require</code> is treated as a normal function that we call with a normal string to get back what we need.</p><p>We can even give the result a well-defined type so that code in the rest of the program continues to have statically strong types, instead of being polluted by the <code class="_1ucarsym"><span class="token keyword">any</span></code>:</p><pre class="_gy9i19"><code class="_1napz9l"><span class="token keyword">type</span> WidgetFrobnicator = (Widget) => <span class="token keyword">void</span>;  <span class="token comment">// whatever the module signature is</span>
<span class="token keyword">const</span> frobnicateWidgets: WidgetFrobnicator =
    <span class="token comment">/*:: ((require: any) => */</span> require(<span class="token string">"./frobnicateWidgets"</span>) <span class="token comment">/*:: )() */</span>;
</code></pre><p>(This works because <code class="_1ucarsym">require</code>, at type <code class="_1ucarsym"><span class="token keyword">any</span></code>, is treated as a function that also <em>returns</em> an <code class="_1ucarsym"><span class="token keyword">any</span></code>, which is then converted to a <code class="_1ucarsym">WidgetFrobnicator</code>.)</p><p>In the <code class="_1ucarsym">peopleNames</code> example, we added some phantom statements to the body of a function. Here, we’re actually changing the structure of the AST. Dangerous? Perhaps. Brittle? Probably. Interesting? Certainly!</p><h2 class="_1htp0dj">Conclusion</h2><p>We have seen how to bend Flow to our will by splicing arbitrary code into its token stream.</p><p>Ridiculous as it seems, this method has some benefits. It’s more precise than using casts through <code class="_1ucarsym"><span class="token keyword">any</span></code>. Using this method, we lie to Flow in a very specific and explicit way, instead of declaring that “all bets are off” for a particular variable and anything that it touches. Indeed, the keyword <code class="_1ucarsym"><span class="token keyword">any</span></code> is itself a grand lie, just one that tends to be better documented and supported.</p><p>The observant reader may recall our motivating suggestion that an ideal solution should be unsurprising to readers and should be written like natural JavaScript code, and protest that we have failed on both these counts.</p><p>Such a reader is 100% correct, but is also no fun at parties, because this hack is way cooler than any “practical”, “enterprise-grade” solution—so there.</p></article><a style="margin-bottom:10px;margin-top:10px" class="_16597jh" href="/posts"><i>« back to posts</i></a></div></article><footer class="_1gtwn3"><div class="_1yyogy7"><a href="https://github.com/wchargin" class="_16597jh"><svg width="16" height="16" style="vertical-align:middle" viewBox="0 0 16 16" alt="GitHub" aria-label="GitHub"><path fill="currentColor" d="m8 0.431c-4.28 0-7.76 3.47-7.76 7.76 0 3.43 2.22 6.34 5.31 7.36 0.388 0.071 0.53-0.168 0.53-0.374 0-0.184-0.007-0.672-0.01-1.32-2.16 0.469-2.61-1.04-2.61-1.04-0.353-0.896-0.862-1.14-0.862-1.14-0.705-0.481 0.053-0.472 0.053-0.472 0.779 0.055 1.19 0.8 1.19 0.8 0.692 1.19 1.82 0.843 2.26 0.645 0.071-0.502 0.271-0.843 0.493-1.04-1.73-0.3-3.54-0.9-3.54-3.91 0-0.847 0.302-1.54 0.799-2.08-0.08-0.2-0.35-0.99 0.07-2.06 0 0 0.652-0.209 2.13 0.796 0.63-0.18 1.29-0.26 1.95-0.27 0.659 0.003 1.32 0.089 1.94 0.261 1.48-1 2.13-0.796 2.13-0.796 0.423 1.07 0.157 1.86 0.077 2.05 0.497 0.542 0.798 1.24 0.798 2.08 0 2.98-1.81 3.64-3.54 3.83 0.279 0.24 0.527 0.713 0.527 1.44 0 1.04-0.01 1.87-0.01 2.13 0 0.208 0.14 0.449 0.534 0.373 3.08-1.03 5.3-3.94 5.3-7.36 0-4.23-3.5-7.71-7.8-7.71z"></path></svg> wchargin</a><br/><span>email me @gmail.com</span></div></footer></div></div>
</body>
</html>
