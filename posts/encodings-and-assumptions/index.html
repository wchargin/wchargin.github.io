<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link rel="shortcut icon" href="/favicon.png" sizes="16x16" />
<link rel="shortcut icon" href="/favicon-256.png" sizes="256x256" />
<link rel="apple touch icon" href="/favicon-256.png" />
<title>Encodings and assumptions</title>
<style>/*! normalize.css v4.1.1 | MIT License | github.com/necolas/normalize.css */
html{font-family:sans-serif;line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress,sub,sup{vertical-align:baseline}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline dotted}b,strong{font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,hr,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{color:inherit;display:table;max-width:100%;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio],legend{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}</style>
<style>p{margin-top:0}</style>
<style>code .comment{color:#6e6e6e}code:not([data-hide-strings]) .string{color:#6e6e6e}code .important{font-style:italic}code .keyword{font-weight:700}code .prompt,code .tt{font-family:monospace}code .prompt{user-select:none}code .property,code .property+.punctuation{font-weight:700}code .tag .tag:first-child{font-weight:700}code .punctuation{font-weight:400}</style>
<style data-aphrodite>._684hqj{font-family:Helvetica, Arial, sans-serif;font-size:16px;color:#121316;line-height:1.5;}._12iqsw5{position:fixed;z-index:-1;top:0px;bottom:0px;width:-webkit-calc(max(400px, 50vw - 420px));width:-moz-calc(max(400px, 50vw - 420px));width:calc(max(400px, 50vw - 420px));left:-webkit-calc(50vw - 420px - max(400px, 50vw - 420px));left:-moz-calc(50vw - 420px - max(400px, 50vw - 420px));left:calc(50vw - 420px - max(400px, 50vw - 420px));background:url(/static/skygradopaque.d6e5e82bc642.jpg), -webkit-linear-gradient(to bottom, #9eabbc 0%, #aebbc3 47%, #c1c0b4 73%, #c3af97 89%, #bd987e 100%);background:url(/static/skygradopaque.d6e5e82bc642.jpg), -moz-linear-gradient(to bottom, #9eabbc 0%, #aebbc3 47%, #c1c0b4 73%, #c3af97 89%, #bd987e 100%);background:url(/static/skygradopaque.d6e5e82bc642.jpg), linear-gradient(to bottom, #9eabbc 0%, #aebbc3 47%, #c1c0b4 73%, #c3af97 89%, #bd987e 100%);background-size:100% 100%;-webkit-mask-image:-webkit-linear-gradient(to right, rgb(0 0 0 / 100%), rgb(0 0 0 / 50%) 25%, transparent);-webkit-mask-image:-moz-linear-gradient(to right, rgb(0 0 0 / 100%), rgb(0 0 0 / 50%) 25%, transparent);-webkit-mask-image:linear-gradient(to right, rgb(0 0 0 / 100%), rgb(0 0 0 / 50%) 25%, transparent);mask-image:-webkit-linear-gradient(to right, rgb(0 0 0 / 100%), rgb(0 0 0 / 50%) 25%, transparent);mask-image:-moz-linear-gradient(to right, rgb(0 0 0 / 100%), rgb(0 0 0 / 50%) 25%, transparent);mask-image:linear-gradient(to right, rgb(0 0 0 / 100%), rgb(0 0 0 / 50%) 25%, transparent);}._1qcuqeh{position:absolute;z-index:-1;top:0px;right:-webkit-calc(50vw + 420px);right:-moz-calc(50vw + 420px);right:calc(50vw + 420px);opacity:0.25;}._37ihjp{border-top:#046375 5px solid;border-bottom:0.5px #cecece solid;margin-bottom:24px;padding-top:10px;padding-bottom:10px;}._tcz2umt{-webkit-box-align:center;-ms-flex-align:center;-webkit-box-pack:justify;-ms-flex-pack:justify;max-width:800px;margin:auto;padding-left:20px;padding-right:20px;display:-webkit-box;display:-moz-box;display:-ms-flexbox;display:-webkit-flex;display:flex;-webkit-justify-content:space-between;justify-content:space-between;-webkit-align-items:center;align-items:center;margin-top:10px;margin-bottom:10px;}._odt2os{font-size:24px;letter-spacing:-0.5px;color:#222;}._1yyogy7{max-width:800px;margin:auto;padding-left:20px;padding-right:20px;}._1gtwn3{color:#6e6e6e;border-top:0.5px #cecece solid;margin-top:24px;padding-top:24px;padding-bottom:24px;}._16597jh{text-decoration:none;color:#0a7f96;}._16597jh:hover{color:#046375;text-decoration:underline;}._16597jh:active{color:#0a7f96;text-decoration:underline;}._1rq9psi{list-style:none;padding-left:0px;margin:0px;}._txtyvv{display:inline;margin-left:20px;}._nqjtz2{margin-top:30px;margin-bottom:10px;font-size:32px;font-weight:normal;}._1htp0dj{margin-top:26px;margin-bottom:8px;font-size:24px;font-weight:normal;}._gy9i19{margin:16px;overflow-x:auto;background:rgba(10,127,150,0.1);border-left:#0a7f96 2px solid;padding:16px;line-height:140%;}._1napz9l{font-family:Helvetica,Arial,sans-serif;}._1ucarsym{font-family:Helvetica,Arial,sans-serif;padding:2px 4px;background:rgba(10,127,150,0.1);white-space:pre-wrap;}@font-face{font-family:Noto Sans;font-style:normal;font-weight:normal;src:url(/static/NotoSansCypriot-Regular.99bc3c9ef984.ttf);}@font-face{font-family:Noto Sans;font-style:normal;font-weight:normal;src:url(/static/NotoSansDeseret-Regular.d42b04d5319c.ttf);}@font-face{font-family:Noto Sans;font-style:normal;font-weight:normal;src:url(/static/NotoSansOldTurkic-Regular.99bbf51f0be1.ttf);}._r4ybfq{font-family:Helvetica,Arial,sans-serif,"Noto Sans";}</style>
<noscript><style>.yesscript{display:none;}</style></noscript>
</head>
<body style="overflow-y:scroll">
<div id="container"><div class="_684hqj"><div class="_12iqsw5"></div><img class="_1qcuqeh" src="/static/leaves.adfcead73f2e.png" width="226" height="400" alt=""/><header class="_37ihjp"><nav class="_tcz2umt"><a class="_odt2os _16597jh" href="/">Willow Chargin</a><ul class="_1rq9psi"><li class="_txtyvv"><a class="_16597jh" href="/"><svg width="14" height="14" viewBox="0 0 16 16" alt="Home" aria-label="Home"><path fill="currentColor" d="M15.45,7L14,5.551V2c0-0.55-0.45-1-1-1h-1c-0.55,0-1,0.45-1,1v0.553L9,0.555C8.727,0.297,8.477,0,8,0S7.273,0.297,7,0.555  L0.55,7C0.238,7.325,0,7.562,0,8c0,0.563,0.432,1,1,1h1v6c0,0.55,0.45,1,1,1h3v-5c0-0.55,0.45-1,1-1h2c0.55,0,1,0.45,1,1v5h3  c0.55,0,1-0.45,1-1V9h1c0.568,0,1-0.437,1-1C16,7.562,15.762,7.325,15.45,7z"></path></svg></a></li><li class="_txtyvv"><a class="_16597jh" href="/posts/">Posts</a></li></ul></nav></header><article class="_1yyogy7"><div><a style="margin-bottom:10px;margin-top:10px" class="_16597jh" href="/posts"><i>« back to posts</i></a><article><div><h1 class="_nqjtz2">Encodings and assumptions</h1><p><i>2017-12-20</i> <!-- -->·<!-- --> <i><a href="https://github.com/wchargin/wchargin.github.io/blob/source/src/pages/posts/data/encodingsAndAssumptions.js" class="_16597jh">view article source</a></i></p></div><p>The best algorithms are simple and elegant. Their implementations are “clearly correct” and have straightforward proofs to this effect. And, sometimes, they are still wrong.</p><p>Usually, this happens because the language in question has primitives whose behavior differs from that of their purely mathematical counterparts. With the binary search implementation proven correct in <i>Programming Pearls</i> and used in the JDK, <a href="https://research.googleblog.com/2006/06/extra-extra-read-all-about-it-nearly.html" class="_16597jh">this was integer overflow</a>. In this article, we explore a case in which encodings are the culprit.</p><h2 class="_1htp0dj">Anagrams</h2><p>Suppose that we want to find all groups of at least five English words that are all anagrams of each other, such as the group [<i>emits</i>, <i>items</i>, <i>mites</i>, <i>smite</i>, <i>times</i>]. A standard approach to tasks like this is to assign a <em>canonical form</em> to each word such that two words have the same canonical form if and only if they are in the same group. Then, we can group words by their canonical forms. For anagrams, the canonical form is created by alphabetizing the letters in each word: <i>eimst</i> is the canonical form for <i>emits</i>, <i>items</i>, and so on. Then, two words have the same canonical form if and only if they are anagrams.</p><p>Here’s some straightforward Java code to implement this algorithm (adapted from <i>Effective Java</i>, third edition; used with permission):</p><pre class="_gy9i19"><code class="_1napz9l"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> printAnagrams(List&lt;String> words, <span class="token keyword">int</span> minGroupSize) {
    Map&lt;String, Set&lt;String>> groups = <span class="token keyword">new</span> HashMap&lt;>();
    <span class="token keyword">for</span> (String word : words) {
        groups.computeIfAbsent(alphabetize(word),
            (unused) -> <span class="token keyword">new</span> TreeSet&lt;>()).add(word);
    }
    <span class="token keyword">for</span> (Set&lt;String> group : groups.values()) {
        <span class="token keyword">if</span> (group.size() >= minGroupSize) {
            System.out.println(group.size() + <span class="token string">": "</span> + group):
        }
    }
}

<span class="token keyword">private</span> <span class="token keyword">static</span> String alphabetize(String s) {
    <span class="token keyword">char</span>[] a = s.toCharArray();
    Arrays.sort(a);
    <span class="token keyword">return</span> <span class="token keyword">new</span> String(a);
}
</code></pre><p>(The call to <code class="_1ucarsym">computeIfAbsent</code> creates a new set the first time we see each canonical form, and returns the existing set for a canonical form if we see it again.)</p><p>Here’s some of the output if we hook it up to a simple <code class="_1ucarsym">main</code> method:</p><pre class="_gy9i19"><code class="_r4ybfq"><span class="token input keyword">$ java Anagrams /usr/share/dict/words 5 | head -n 3</span>
5: [alerting, altering, integral, relating, triangle]
6: [opts, post, pots, spot, stop, tops]
5: [drawer, redraw, reward, warder, warred]
</code></pre><p>Well, it sure looks like it’s doing the right thing. But, of course, you already know that it’s not.</p><p>The culprit is the <code class="_1ucarsym">alphabetize</code> function, and in particular its call to <code class="_1ucarsym">Arrays.sort(a)</code>, which sorts the character array <code class="_1ucarsym">a</code> by its numeric values. The JLS guarantees that a <code class="_1ucarsym">char</code> stores a 16-bit unsigned integer value—it always has, and it always will. When Java was created, this was a perfectly reasonable choice: there were just a few thousand Unicode characters, fitting comfortably into 16 bits. (Indeed, it was progressive for Java to not stick with the “a character is a byte and ASCII is all that there will ever be” philosophy.) But by the release of Java 1.5, the Unicode standard had expanded to define more than 65,536 code points, and thus a <code class="_1ucarsym">char</code> was no longer wide enough to hold a Unicode character. Widening the primitive <code class="_1ucarsym">char</code> type to be a 32-bit type would have been catastrophic for backward compatibility, so the Java language designers did the sensible thing and instead decided that strings would use UTF-16 (a backward-compatible encoding).</p><p>There’s just one problem with UTF-16: it makes our implementation of <code class="_1ucarsym">alphabetize</code> incorrect.</p><h2 class="_1htp0dj">Surrogates</h2><p>UTF-16 is a variable-length encoding. Each Unicode code point is represented as one or more 16-bit <em>code units</em> (i.e., <code class="_1ucarsym">char</code> values). Code points with small values are represented by a <em>single</em> code unit with value equal to its code point. Code points greater than U+FFFF are represented by a <em>surrogate pair</em>: two code units, one with value between 0xD800 and 0xDBFF (encoding the high bits of the code point), and one with value between 0xDC00 and 0xDFFF (encoding the low bits).</p><p>From this description, it’s not immediately clear why sorting the code units is problematic. The high surrogate precedes the low surrogate in the code unit stream, and its value is also smaller, so the relative order of the surrogates should be preserved by the sort. Furthermore, the ranges of the high and low surrogates are disjoint, so even if we did somehow swap the surrogates we would still be able to tell them apart: we wouldn’t be throwing away information.</p><p>And, indeed, the <code class="_1ucarsym">alphabetize</code> function works fine when a string has just one surrogate pair. It’s when there are multiple surrogate pairs that we can have problems. Consider the code unit sequences</p><blockquote>D801 DC02 D803 DC04</blockquote><p>and</p><blockquote>D801 DC04 D803 DC02.</blockquote><p>Each is a valid UTF-16 string with two surrogate pairs, but the surrogates are paired up differently, and so they represent different code points. The first string is U+10402 U+10C04; the second is U+10404 U+10C02. The catch, of course, is that while these strings are not anagrams, their arrays of UTF-16 code units <em>are</em> anagrams—they sort to the same array, and so our program groups them together:</p><pre class="_gy9i19"><code class="_r4ybfq"><span class="token input keyword">$ cat example</span>
𐐂𐰄
𐐄𐰂
<span class="token input keyword">$ xxd example</span>
<span class="token xxd tt">00000000: f090 9082 f090 b084 0af0 9090 84f0 90b0  ................</span>
<span class="token xxd tt">00000010: 820a                                     ..</span>
<span class="token input keyword">$ java Anagrams example 1</span>
2: [𐐂𐰄, 𐐄𐰂]
</code></pre><p>Whoops!</p><h2 class="_1htp0dj">Decoders</h2><p>So, we have a broken anagrams program. How can we fix it?</p><p>In Java 7 and prior versions, we’d be in a bit of a bind. The <code class="_1ucarsym">String</code> class provides some methods for decoding into arrays of bytes, but not into arrays of code points. UTF-16 is a simple format, so it’s not very difficult to write our own, but the resulting decoder <em>is</em> longer than the rest of the program:</p><pre class="_gy9i19"><code class="_1napz9l"><span class="token keyword">private</span> <span class="token keyword">static</span> List&lt;Integer> codePointsOf(String s) {
    <span class="token keyword">final</span> List&lt;Integer> result = <span class="token keyword">new</span> ArrayList&lt;>();
    <span class="token keyword">final</span> <span class="token keyword">char</span>[] chars = s.toCharArray();
    <span class="token keyword">for</span> (<span class="token keyword">int</span> i = 0; i &lt; chars.length; i++) {
        <span class="token keyword">final</span> <span class="token keyword">char</span> here = chars[i];
        <span class="token keyword">if</span> (here &lt; 0xD800 || here > 0xDFFF) {
            result.add((<span class="token keyword">int</span>) here);
        } <span class="token keyword">else</span> {
            <span class="token keyword">if</span> (i + 1 >= chars.length) {
                <span class="token keyword">throw</span> <span class="token keyword">new</span> IllegalArgumentException(
                        <span class="token string">"Incomplete surrogate at index "</span> + i);
            }
            <span class="token keyword">final</span> <span class="token keyword">char</span> next = chars[++i];
            <span class="token keyword">if</span> (0xD800 &lt;= here &amp;&amp; here &lt;= 0xDBFF
                    &amp;&amp; 0xDC00 &lt;= next &amp;&amp; next &lt;= 0xDFFF) {
                result.add(
                        (((<span class="token keyword">int</span>) here - 0xD800) &lt;&lt; 10)
                        + ((<span class="token keyword">int</span>) next - 0xDC00)
                        + 0x010000);
            } <span class="token keyword">else</span> {
                <span class="token keyword">throw</span> <span class="token keyword">new</span> IllegalArgumentException(
                        <span class="token string">"Invalid surrogate pair at index "</span> + (i - 1));
            }
        }
    }
    <span class="token keyword">return</span> result;
}

<span class="token keyword">private</span> <span class="token keyword">static</span> List&lt;Integer> alphabetize(String s) {
    <span class="token keyword">final</span> List&lt;Integer> codePoints = codePointsOf(s);
    Collections.sort(codePoints);
    <span class="token keyword">return</span> codePoints;
}
</code></pre><p>Note that we’ve had to change the return type method of <code class="_1ucarsym">alphabetize</code> to be a list of code points rather than a string: otherwise, we would have had to write an encoder, too, and that’s twice the work!</p><p>As of Java 8, there’s a better way. We can use a new method on <code class="_1ucarsym">CharSequence</code> (a supertype of <code class="_1ucarsym">String</code>) to accomplish our goal concisely, elegantly, and correctly:</p><pre class="_gy9i19"><code class="_1napz9l"><span class="token keyword">private</span> <span class="token keyword">static</span> String alphabetize(String s) {
    <span class="token keyword">int</span>[] newCodePoints = s.codePoints().sorted().toArray();
    <span class="token keyword">return</span> <span class="token keyword">new</span> String(newCodePoints, 0, newCodePoints.length);
}
</code></pre><p>As a bonus, it’s a line shorter than our original, incorrect version.</p><h2 class="_1htp0dj">Conclusion</h2><p>This post used Java as the working language, but the underlying issue is language-agnostic. When we develop programs, we must be aware of the quirks and footguns hidden in our building blocks. Aside from encodings and bounded integer arithmetic, the behavior of floating-point numbers is another common stumbling ground.</p><p>How does your favorite language represent strings? It might be worth finding out.</p><h2 class="_1htp0dj">Appendix: Benchmarks and a full program</h2><p>You can find full implementations and benchmarks at <a href="https://github.com/wchargin/anagrams-benchmark" class="_16597jh">wchargin/anagrams-benchmark</a>, which tests ten variants of these algorithms. The executive summary of the benchmarks is: the correct version is about 50% slower than the naive version.</p><p>Here’s a standalone version of the fixed program:</p><pre class="_gy9i19"><code class="_1napz9l"><span class="token keyword">import</span> java.io.*;
<span class="token keyword">import</span> java.util.*;

<span class="token keyword">public</span> <span class="token keyword">class</span> AnagramsV2 {
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> main(String[] args) <span class="token keyword">throws</span> IOException {
        <span class="token keyword">final</span> String fileName = args[0];
        <span class="token keyword">final</span> <span class="token keyword">int</span> minGroupSize = Integer.parseInt(args[1]);

        <span class="token comment">// Read words from file and put into a simulated multimap</span>
        Map&lt;String, Set&lt;String>> groups = <span class="token keyword">new</span> HashMap&lt;>();
        <span class="token keyword">try</span> (<span class="token keyword">final</span> Scanner s = <span class="token keyword">new</span> Scanner(<span class="token keyword">new</span> File(fileName))) {
            <span class="token keyword">while</span> (s.hasNext()) {
                <span class="token keyword">final</span> String word = s.next();
                groups.computeIfAbsent(alphabetize(word),
                        (unused) -> <span class="token keyword">new</span> TreeSet&lt;>()).add(word);
            }
        }

        <span class="token comment">// Print all anagram groups above size threshold</span>
        <span class="token keyword">for</span> (<span class="token keyword">final</span> Set&lt;String> group : groups.values())
            <span class="token keyword">if</span> (group.size() >= minGroupSize)
                System.out.println(group.size() + <span class="token string">": "</span> + group);
    }

    <span class="token keyword">private</span> <span class="token keyword">static</span> String alphabetize(String s) {
        <span class="token keyword">int</span>[] newCodePoints = s.codePoints().sorted().toArray();
        <span class="token keyword">return</span> <span class="token keyword">new</span> String(newCodePoints, 0, newCodePoints.length);
    }
}
</code></pre><p>And some sample output (the best proof of correctness):</p><pre class="_gy9i19"><code class="_r4ybfq"><span class="token input keyword">$ cat words</span>
𐐄𐠃
𐐃𐠄
𐐂𐰄
𐐄𐰂
𐰄𐐂
𐰂𐐄
pastel
staple
plates
syzygy
ten
net
t👍n
n👍t
t👎n
<span class="token input keyword">$ xxd words</span>
<span class="token xxd tt">00000000: f090 9084 f090 a083 0af0 9090 83f0 90a0  ................</span>
<span class="token xxd tt">00000010: 840a f090 9082 f090 b084 0af0 9090 84f0  ................</span>
<span class="token xxd tt">00000020: 90b0 820a f090 b084 f090 9082 0af0 90b0  ................</span>
<span class="token xxd tt">00000030: 82f0 9090 840a 7061 7374 656c 0a73 7461  ......pastel.sta</span>
<span class="token xxd tt">00000040: 706c 650a 706c 6174 6573 0a73 797a 7967  ple.plates.syzyg</span>
<span class="token xxd tt">00000050: 790a 7465 6e0a 6e65 740a 74f0 9f91 8d6e  y.ten.net.t....n</span>
<span class="token xxd tt">00000060: 0a6e f09f 918d 740a 74f0 9f91 8e6e 0a    .n....t.t....n.</span>
<span class="token input keyword">$ javac AnagramsV2.java &amp;&amp; java AnagramsV2 words 1</span>
3: [pastel, plates, staple]
1: [𐐃𐠄]
1: [𐐄𐠃]
2: [𐐄𐰂, 𐰂𐐄]
2: [𐐂𐰄, 𐰄𐐂]
2: [n👍t, t👍n]
1: [t👎n]
2: [net, ten]
1: [syzygy]
</code></pre></article><a style="margin-bottom:10px;margin-top:10px" class="_16597jh" href="/posts"><i>« back to posts</i></a></div></article><footer class="_1gtwn3"><div class="_1yyogy7"><a href="https://github.com/wchargin" class="_16597jh"><svg width="16" height="16" style="vertical-align:middle" viewBox="0 0 16 16" alt="GitHub" aria-label="GitHub"><path fill="currentColor" d="m8 0.431c-4.28 0-7.76 3.47-7.76 7.76 0 3.43 2.22 6.34 5.31 7.36 0.388 0.071 0.53-0.168 0.53-0.374 0-0.184-0.007-0.672-0.01-1.32-2.16 0.469-2.61-1.04-2.61-1.04-0.353-0.896-0.862-1.14-0.862-1.14-0.705-0.481 0.053-0.472 0.053-0.472 0.779 0.055 1.19 0.8 1.19 0.8 0.692 1.19 1.82 0.843 2.26 0.645 0.071-0.502 0.271-0.843 0.493-1.04-1.73-0.3-3.54-0.9-3.54-3.91 0-0.847 0.302-1.54 0.799-2.08-0.08-0.2-0.35-0.99 0.07-2.06 0 0 0.652-0.209 2.13 0.796 0.63-0.18 1.29-0.26 1.95-0.27 0.659 0.003 1.32 0.089 1.94 0.261 1.48-1 2.13-0.796 2.13-0.796 0.423 1.07 0.157 1.86 0.077 2.05 0.497 0.542 0.798 1.24 0.798 2.08 0 2.98-1.81 3.64-3.54 3.83 0.279 0.24 0.527 0.713 0.527 1.44 0 1.04-0.01 1.87-0.01 2.13 0 0.208 0.14 0.449 0.534 0.373 3.08-1.03 5.3-3.94 5.3-7.36 0-4.23-3.5-7.71-7.8-7.71z"></path></svg> wchargin</a><br/><span>email me @gmail.com</span></div></footer></div></div>
</body>
</html>
