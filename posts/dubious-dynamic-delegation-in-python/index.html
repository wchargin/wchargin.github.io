<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link rel="shortcut icon" href="/favicon.png" sizes="16x16" />
<link rel="shortcut icon" href="/favicon-256.png" sizes="256x256" />
<link rel="apple touch icon" href="/favicon-256.png" />
<title>Dubious dynamic delegation in Python</title>
<style>/*! normalize.css v4.1.1 | MIT License | github.com/necolas/normalize.css */
html{font-family:sans-serif;line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress,sub,sup{vertical-align:baseline}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline dotted}b,strong{font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,hr,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{color:inherit;display:table;max-width:100%;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio],legend{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}</style>
<style>p{margin-top:0}</style>
<style>code .comment{color:#6e6e6e}code:not([data-hide-strings]) .string{color:#6e6e6e}code .important{font-style:italic}code .keyword{font-weight:700}code .prompt,code .tt{font-family:monospace}code .prompt{user-select:none}</style>
<style data-aphrodite>._684hqj{font-family:Helvetica, Arial, sans-serif;font-size:16px;color:#121316;line-height:1.5;}._37ihjp{border-top:#046375 5px solid;border-bottom:0.5px #cecece solid;margin-bottom:24px;padding-top:10px;padding-bottom:10px;}._tcz2umt{-webkit-box-align:center;-ms-flex-align:center;-webkit-box-pack:justify;-ms-flex-pack:justify;max-width:800px;margin:auto;padding-left:20px;padding-right:20px;display:-webkit-box;display:-moz-box;display:-ms-flexbox;display:-webkit-flex;display:flex;-webkit-justify-content:space-between;justify-content:space-between;-webkit-align-items:center;align-items:center;margin-top:10px;margin-bottom:10px;}._odt2os{font-size:24px;letter-spacing:-0.5px;color:#222;}._1yyogy7{max-width:800px;margin:auto;padding-left:20px;padding-right:20px;}._1gtwn3{color:#6e6e6e;border-top:0.5px #cecece solid;margin-top:24px;padding-top:24px;padding-bottom:24px;}._16597jh{text-decoration:none;color:#0a7f96;}._16597jh:hover{color:#046375;text-decoration:underline;}._16597jh:active{color:#0a7f96;text-decoration:underline;}._1rq9psi{list-style:none;padding-left:0px;margin:0px;}._txtyvv{display:inline;margin-left:20px;}._nqjtz2{margin-top:30px;margin-bottom:10px;font-size:32px;font-weight:normal;}._1ucarsym{font-family:Helvetica,Arial,sans-serif;padding:2px 4px;background:rgba(10,127,150,0.1);white-space:pre-wrap;}._1htp0dj{margin-top:26px;margin-bottom:8px;font-size:24px;font-weight:normal;}._gy9i19{margin:16px;overflow-x:auto;background:rgba(10,127,150,0.1);border-left:#0a7f96 2px solid;padding:16px;line-height:140%;}._1napz9l{font-family:Helvetica,Arial,sans-serif;}</style>
<noscript><style>.yesscript{display:none;}</style></noscript>
</head>
<body style="overflow-y:scroll">
<div id="container"><div class="_684hqj"><header class="_37ihjp"><nav class="_tcz2umt"><a class="_odt2os _16597jh" href="/">wchargin</a><ul class="_1rq9psi"><li class="_txtyvv"><a class="_16597jh" href="/"><svg width="14" height="14" viewBox="0 0 16 16" alt="Home" aria-label="Home"><path fill="currentColor" d="M15.45,7L14,5.551V2c0-0.55-0.45-1-1-1h-1c-0.55,0-1,0.45-1,1v0.553L9,0.555C8.727,0.297,8.477,0,8,0S7.273,0.297,7,0.555  L0.55,7C0.238,7.325,0,7.562,0,8c0,0.563,0.432,1,1,1h1v6c0,0.55,0.45,1,1,1h3v-5c0-0.55,0.45-1,1-1h2c0.55,0,1,0.45,1,1v5h3  c0.55,0,1-0.45,1-1V9h1c0.568,0,1-0.437,1-1C16,7.562,15.762,7.325,15.45,7z"></path></svg></a></li><li class="_txtyvv"><a class="_16597jh" href="/posts/">Posts</a></li></ul></nav></header><article class="_1yyogy7"><div><a style="margin-bottom:10px;margin-top:10px" class="_16597jh" href="/posts"><i>« back to posts</i></a><article><div><h1 class="_nqjtz2">Dubious dynamic delegation in Python</h1><p><i>2019-11-10</i> <!-- -->·<!-- --> <i><a href="https://github.com/wchargin/wchargin.github.io/blob/source/src/pages/posts/data/dubiousDynamicDelegation.js" class="_16597jh">view article source</a></i></p></div><p>I recently had the occasion to use a <code class="_1ucarsym"><span class="token keyword">for</span></code>-loop directly inside a class definition in Python. Discovering that this was possible was a bit surprising. Realizing that there is a sense in which it was the <em>best</em> solution was more surprising still. This is that story.</p><h2 class="_1htp0dj">Interfaces and delegation</h2><p>Python doesn’t have a native concept of interfaces, traits, protocols, or anything of the sort. This is too bad: even though Python prefers to implicitly treat <em>implementations</em> interchangeably via duck typing, explicitly defining an interface is still super useful because it provides a place to document the interface’s syntax and semantics. To this end, Python provides an <code class="_1ucarsym">abc</code> module for defining abstract base classes.</p><p>As a running example, let’s define a simple file system interface. Abbreviating docs for brevity:</p><pre class="_gy9i19"><code class="_1napz9l"><span class="token keyword">import</span> abc
<span class="token keyword">import</span> six

@six.add_metaclass(abc.ABCMeta)
<span class="token keyword">class</span> FileSystem(object):
    <span class="token tqs string">"""Abstract file system interface."""</span>

    @abc.abstractmethod
    <span class="token keyword">def</span> open(self, path, mode=<span class="token string">"r"</span>):
        <span class="token tqs string">"""Open a file for reading or writing."""</span>
        <span class="token keyword">pass</span>

    @abc.abstractmethod
    <span class="token keyword">def</span> remove(self, path):
        <span class="token tqs string">"""Remove a file."""</span>
        <span class="token keyword">pass</span>

    @abc.abstractmethod
    <span class="token keyword">def</span> listdir(self, path):
        <span class="token tqs string">"""List files in the given directory."""</span>
        <span class="token keyword">pass</span>

    @abc.abstractmethod
    <span class="token keyword">def</span> stat(self, path):
        <span class="token tqs string">"""Perform a `stat`(2) system call equivalent."""</span>
        <span class="token keyword">pass</span>

    @abc.abstractmethod
    <span class="token keyword">def</span> readlink(self, path):
        <span class="token tqs string">"""Resolve a symbolic link to its referent."""</span>
        <span class="token keyword">pass</span>
</code></pre><p>The <code class="_1ucarsym">ABCMeta</code> metaclass will prevent us from directly instantiating any instances of this class:</p><pre class="_gy9i19"><code class="_1napz9l"><span class="token repl-marker prompt">>>> </span><span class="token keyword">import</span> main
<span class="token repl-marker prompt">>>> </span>main.FileSystem()
<span class="token comment">Traceback (most recent call last):</span>
<span class="token comment">  File "&lt;string>", line 1, in &lt;module></span>
<span class="token comment">TypeError: Can't instantiate abstract class FileSystem with abstract methods listdir, open, readlink, remove, stat</span>
</code></pre><p>If we subclass our <code class="_1ucarsym">FileSystem</code> class and implement all the methods, we can instantiate that subclass:</p><pre class="_gy9i19"><code class="_1napz9l"><span class="token keyword">import</span> os

<span class="token keyword">class</span> NativeFileSystem(FileSystem):
    <span class="token tqs string">"""File system backed by the operating system."""</span>

    <span class="token keyword">def</span> open(self, path, mode=<span class="token string">"r"</span>):
        <span class="token keyword">return</span> open(path, mode)

    <span class="token keyword">def</span> remove(self, path):
        <span class="token keyword">return</span> os.remove(path)

    <span class="token keyword">def</span> listdir(self, path):
        <span class="token keyword">return</span> os.listdir(path)

    <span class="token keyword">def</span> stat(self, path):
        <span class="token keyword">return</span> os.stat(path)

    <span class="token keyword">def</span> readlink(self, path):
        <span class="token keyword">return</span> os.readlink(path)

NativeFileSystem()  <span class="token comment"># OK!</span>
</code></pre><p>So far, so good. Now, suppose that we have a few implementations of our file system interface: say, the native file system, a couple of implementations backed by network file systems from various cloud service providers, and an in-memory file system for use in tests. We may want to write an adapter that wraps an arbitrary file system and only allows read-only operations. Like this:</p><pre class="_gy9i19"><code class="_1napz9l"><span class="token keyword">class</span> ReadOnlyFileSystem(FileSystem):
    <span class="token tqs string">"""Adapter to make a filesystem read-only (first attempt)."""</span>

    <span class="token keyword">def</span> __init__(self, delegate):
        self._delegate = delegate

    <span class="token keyword">def</span> open(self, path, mode=<span class="token string">"r"</span>):
        <span class="token keyword">if</span> <span class="token logical keyword">not</span> mode.startswith(<span class="token string">"r"</span>):
            <span class="token keyword">raise</span> RuntimeError(<span class="token string">"Cannot open as %r: read-only filesystem"</span> % mode)
        <span class="token keyword">return</span> self._delegate.open(path, mode)

    <span class="token keyword">def</span> remove(self, path):
        <span class="token keyword">raise</span> RuntimeError(<span class="token string">"Cannot remove file: read-only filesystem"</span>)

    <span class="token keyword">def</span> listdir(self, path):
        <span class="token keyword">return</span> self._delegate.listdir(path)

    <span class="token keyword">def</span> stat(self, path):
        <span class="token keyword">return</span> self._delegate.stat(path)

    <span class="token keyword">def</span> readlink(self, path):
        <span class="token keyword">return</span> self._delegate.readlink(path)
</code></pre><p>This works just fine. But there’s a fair amount of duplication—the <code class="_1ucarsym">listdir</code>, <code class="_1ucarsym">stat</code>, and <code class="_1ucarsym">readlink</code> methods are basically identical. That doesn’t feel very Pythonic. Let’s see if we can get rid of it.</p><h2 class="_1htp0dj">Attempt: <code class="_1ucarsym">__getattribute__</code></h2><p>Thanks to Python’s dynamism, this seems like it should be easy to achieve. We can skip implementing the pass-through methods and instead dispatch dynamically in <code class="_1ucarsym">__getattr__</code>:</p><pre class="_gy9i19"><code class="_1napz9l"><span class="token keyword">class</span> ReadOnlyFileSystem(FileSystem):
    <span class="token tqs string">"""Adapter to make a filesystem read-only (second attempt)."""</span>

    <span class="token keyword">def</span> __init__(self, delegate):
        self._delegate = delegate

    <span class="token keyword">def</span> open(self, path, mode=<span class="token string">"r"</span>):
        <span class="token keyword">if</span> <span class="token logical keyword">not</span> mode.startswith(<span class="token string">"r"</span>):
            <span class="token keyword">raise</span> RuntimeError(<span class="token string">"Cannot open as %r: read-only filesystem"</span> % mode)
        <span class="token keyword">return</span> self._delegate.open(path, mode)

    <span class="token keyword">def</span> remove(self, path):
        <span class="token keyword">raise</span> RuntimeError(<span class="token string">"Cannot remove file: read-only filesystem"</span>)

    <span class="token keyword">def</span> __getattribute__(self, attr):
        <span class="token keyword">if</span> attr <span class="token keyword">in</span> (<span class="token string">"listdir"</span>, <span class="token string">"stat"</span>, <span class="token string">"readlink"</span>):
            <span class="token keyword">return</span> getattr(self._delegate, attr)
        <span class="token keyword">else</span>:
            <span class="token keyword">return</span> super(ReadOnlyFileSystem, self).__getattribute__(attr)
</code></pre><p>(Note that we need to use <code class="_1ucarsym">__getattribute__</code> rather than the more common <code class="_1ucarsym">__getattr__</code>. The latter is only consulted on failed attribute lookups, which sounds like what we want, but attribute lookups for the unimplemented abstract methods actually don’t fail because those methods exist on the superclass.)</p><p>The runtime semantics of this are correct. If we were to remove the <code class="_1ucarsym">ABCMeta</code> metaclass from the base class, this would work perfectly. But, alas!—the <code class="_1ucarsym">abc</code> instantiation check is not appeased:</p><pre class="_gy9i19"><code class="_1napz9l"><span class="token repl-marker prompt">>>> </span><span class="token keyword">import</span> main
<span class="token repl-marker prompt">>>> </span>main.ReadOnlyFileSystem(main.NativeFileSystem())
<span class="token comment">Traceback (most recent call last):</span>
<span class="token comment">  File "&lt;string>", line 1, in &lt;module></span>
<span class="token comment">TypeError: Can't instantiate abstract class ReadOnlyFileSystem with abstract methods listdir, readlink, stat</span>
</code></pre><p>It has fewer complaints than last time, as we’ve explicitly implemented two of the methods, but it’s not taking into account those methods that are dispatched dynamically.</p><h2 class="_1htp0dj">Attempt: attaching methods onto the derived class</h2><p>Okay, fair enough: those methods aren’t actually defined on the <code class="_1ucarsym">ReadOnlyFileSystem</code> class, so it’s understandable that the <code class="_1ucarsym">abc</code> machinery might not be able to pick them up. But that shouldn’t be a big deal. Python is happy to let us monkey-patch attributes onto a class, so we can try that:</p><pre class="_gy9i19"><code class="_1napz9l"><span class="token keyword">class</span> ReadOnlyFileSystem(FileSystem):
    <span class="token tqs string">"""Adapter to make a filesystem read-only (third attempt)."""</span>

    <span class="token keyword">def</span> __init__(self, delegate):
        self._delegate = delegate

    <span class="token keyword">def</span> open(self, path, mode=<span class="token string">"r"</span>):
        <span class="token keyword">if</span> <span class="token logical keyword">not</span> mode.startswith(<span class="token string">"r"</span>):
            <span class="token keyword">raise</span> RuntimeError(<span class="token string">"Cannot open as %r: read-only filesystem"</span> % mode)
        <span class="token keyword">return</span> self._delegate.open(path, mode)

    <span class="token keyword">def</span> remove(self, path):
        <span class="token keyword">raise</span> RuntimeError(<span class="token string">"Cannot remove file: read-only filesystem"</span>)


<span class="token keyword">for</span> method_name <span class="token keyword">in</span> (<span class="token string">"listdir"</span>, <span class="token string">"stat"</span>, <span class="token string">"readlink"</span>):
    <span class="token keyword">def</span> delegator(self, *args, **kwargs):
        <span class="token keyword">return</span> getattr(self._delegate, method_name)(*args, **kwargs)
    setattr(ReadOnlyFileSystem, method_name, delegator)
</code></pre><p>This is actually broken even without any <code class="_1ucarsym">abc</code> considerations. The intent was that the <code class="_1ucarsym">listdir</code> delegator method should call <code class="_1ucarsym">listdir</code> on the delegate. But actually <code class="_1ucarsym">listdir</code> will call <code class="_1ucarsym">readlink</code>! This is because <code class="_1ucarsym">delegator</code> doesn’t actually <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)" class="_16597jh">close over</a> the value of <code class="_1ucarsym">method_name</code>. Instead, it treats it as a global variable, and the value of the global variable changes at each loop iteration. To fix this, we have to explicitly bind <code class="_1ucarsym">method_name</code> to a function parameter:</p><pre class="_gy9i19"><code class="_1napz9l"><span class="token keyword">def</span> make_delegator(method_name):
    <span class="token keyword">def</span> delegator(self, *args, **kwargs):
        <span class="token keyword">return</span> getattr(self._delegate, method_name)(*args, **kwargs)
    <span class="token keyword">return</span> delegator
<span class="token keyword">for</span> method_name <span class="token keyword">in</span> (<span class="token string">"listdir"</span>, <span class="token string">"stat"</span>, <span class="token string">"readlink"</span>):
    setattr(ReadOnlyFileSystem, method_name, make_delegator(method_name))
</code></pre><p>This fixes the monkey-patching mechanics. But it still doesn’t suffice to satisfy the abstract method check:</p><pre class="_gy9i19"><code class="_1napz9l"><span class="token repl-marker prompt">>>> </span><span class="token keyword">import</span> main
<span class="token repl-marker prompt">>>> </span>main.ReadOnlyFileSystem(main.NativeFileSystem())
<span class="token comment">Traceback (most recent call last):</span>
<span class="token comment">  File "&lt;string>", line 1, in &lt;module></span>
<span class="token comment">TypeError: Can't instantiate abstract class ReadOnlyFileSystem with abstract methods listdir, readlink, stat</span>
</code></pre><p>Consulting the <a href="https://docs.python.org/3/library/abc.html" class="_16597jh"><code class="_1ucarsym">abc</code> module documentation</a>, we can see that this is intended:</p><blockquote>Dynamically adding abstract methods to a class, or attempting to modify the abstraction status of a method or class once it is created, are not supported.</blockquote><p>And, consulting the <a href="https://github.com/python/cpython/blob/86c17c06c9420040c79c29ecf924741f37975342/Lib/abc.py#L143" class="_16597jh">CPython source code</a>—the only way to <em>really</em> understand anything in Python—we see that indeed the <code class="_1ucarsym">__abstractmethods__</code> attribute is set at class creation time. (The astute reader will note that the value of <code class="_1ucarsym">__abstractmethods__</code> is never actually read within that module. That’s because the actual check happens in the C code for the interpreter’s core <code class="_1ucarsym">object_new</code> function. Don’t ask.)</p><p>It would appear that we’re in a bit of a bind. By the time that we start monkey-patching the class, the verdict has already been decided, and it is not in our favor.</p><h2 class="_1htp0dj">A highly magical solution</h2><p>Here’s where it starts getting a bit more unorthodox.</p><p>In Python, a class definition—that is, the <code class="_1ucarsym"><span class="token keyword">class</span> Foo: ...</code> line and everything inside the class body—is actually a statement. It’s executed roughly as follows:</p><ol><li>Evaluate each expression in the sequence of base classes (usually just <code class="_1ucarsym">object</code>).</li><li>Create a new empty namespace for the class attributes.</li><li>Execute the statements in the class body in the context of the new namespace.</li><li>Invoke the metaclass’s constructor (usually just <code class="_1ucarsym">type</code>) with the class name, the sequence of base classes, and the namespace that has just been populated.</li><li>Store the resulting type object onto the namespace under the class name.</li></ol><p>So, for example, given the following simple class definition…</p><pre class="_gy9i19"><code class="_1napz9l"><span class="token keyword">class</span> MyClass(object):
    X = 1

    <span class="token keyword">def</span> foo(self):
        <span class="token keyword">pass</span>
</code></pre><p>…the steps are:</p><ol><li>Evaluate the expression <code class="_1ucarsym">object</code> to form the sequence of base classes <code class="_1ucarsym">(object,)</code> (a length-1 tuple).</li><li>Create a new empty namespace.</li><li>Execute <code class="_1ucarsym">X = 1</code> and <code class="_1ucarsym"><span class="token keyword">def</span> foo(self): <span class="token keyword">pass</span></code> in this new namespace. This assigns keys <code class="_1ucarsym">X</code> and <code class="_1ucarsym">foo</code> onto the namespace, with values <code class="_1ucarsym">1</code> and a new function object, respectively.</li><li>Invoke <code class="_1ucarsym">type(<span class="token string">"MyClass"</span>, (object,), namespace)</code>, where <code class="_1ucarsym">namespace</code> is the namespace populated in the previous step.</li><li>Set <code class="_1ucarsym">MyClass</code> on the global namespace to the resulting type object.</li></ol><p>You can perform step (4) in normal Python code, too. This can often be convenient for quick one-liners and explorations where you want to remain in an expression context:</p><pre class="_gy9i19"><code class="_1napz9l"><span class="token repl-marker prompt">>>> </span>type(<span class="token string">"MyClass"</span>, (object,), {<span class="token string">"X"</span>: 1, <span class="token string">"foo"</span>: <span class="token keyword">lambda</span> self: None})
<span class="token comment">&lt;class '__main__.MyClass'></span>
</code></pre><p>Now, the statements inside the class definition are <em>usually</em> simple assignments and function definitions, but they don’t <em>need</em> to be! For instance, the following is a valid class definition:</p><pre class="_gy9i19"><code class="_1napz9l"><span class="token keyword">class</span> MyClass(object):
    <span class="token keyword">import</span> random
    <span class="token keyword">with</span> open(<span class="token string">"threshold.txt"</span>) <span class="token keyword">as</span> infile:
        <span class="token keyword">if</span> random.random() &lt; float(infile.read()):
            lucky = True
</code></pre><p>The resulting class will always have attributes <code class="_1ucarsym">random</code> (the imported module) and <code class="_1ucarsym">infile</code> (the closed file object). Depending on the contents of <code class="_1ucarsym">threshold.txt</code> and the whims of entropy, it may also have an attribute <code class="_1ucarsym">lucky</code>.</p><p>Surely we must be able to use this to solve our delegation problem. All we need to do is make sure that the desired methods are defined on the namespace by the time that the class body finishes executing. We want to do something morally equivalent to the following:</p><pre class="_gy9i19"><code class="_1napz9l"><span class="token keyword">class</span> ReadOnlyFileSystem(FileSystem):
    <span class="token tqs string">"""Adapter to make a filesystem read-only (fourth attempt)."""</span>

    <span class="token keyword">def</span> __init__(self, delegate):
        self._delegate = delegate

    <span class="token keyword">def</span> open(self, path, mode=<span class="token string">"r"</span>):
        <span class="token keyword">if</span> <span class="token logical keyword">not</span> mode.startswith(<span class="token string">"r"</span>):
            <span class="token keyword">raise</span> RuntimeError(<span class="token string">"Cannot open as %r: read-only filesystem"</span> % mode)
        <span class="token keyword">return</span> self._delegate.open(path, mode)

    <span class="token keyword">def</span> remove(self, path):
        <span class="token keyword">raise</span> RuntimeError(<span class="token string">"Cannot remove file: read-only filesystem"</span>)

    <span class="token comment"># Note: Loop moved into class body!</span>
    <span class="token keyword">for</span> method_name <span class="token keyword">in</span> (<span class="token string">"listdir"</span>, <span class="token string">"stat"</span>, <span class="token string">"readlink"</span>):
        <span class="token keyword">def</span> delegator(self, *args, **kwargs):
            <span class="token keyword">return</span> getattr(self._delegate, method_name)(*args, **kwargs)
        setattr(ReadOnlyFileSystem, method_name, delegator)
</code></pre><p>This doesn’t quite work as written. When we execute the <code class="_1ucarsym">setattr</code> on the last line, the <code class="_1ucarsym">ReadOnlyFileSystem</code> identifier has not yet been assigned onto the module namespace. This makes sense—the type object hasn’t been created yet, so we can’t refer to it. But we don’t really need to refer to the type object; we only care about the temporary namespace that we’re populating. And Python <em>does</em> expose a way to access that—the <code class="_1ucarsym">vars</code> and <code class="_1ucarsym">locals</code> builtins!</p><p>The <a href="https://docs.python.org/3/library/functions.html#vars" class="_16597jh">documentation for <code class="_1ucarsym">vars</code></a> clearly states that “the locals dictionary is only useful for reads since updates to the locals dictionary are ignored”. The <a href="https://docs.python.org/3/library/functions.html#locals" class="_16597jh">underlying <code class="_1ucarsym">locals</code> function</a> also says that “[t]he contents of this dictionary should not be modified”. But like most everything else in Python, this “should” is really just a suggestion, and the admonition on <code class="_1ucarsym">vars</code> is as wrong as it is unambiguous: updating <code class="_1ucarsym">vars()</code> or <code class="_1ucarsym">locals()</code> has worked fine since at least CPython 2.7 and through at least CPython 3.8 (latest at time of writing). So, pulling everything together, and with a final touch of discovering the needed method names dynamically with <code class="_1ucarsym">__abstractmethods__</code>, we behold:</p><pre class="_gy9i19"><code class="_1napz9l"><span class="token keyword">class</span> ReadOnlyFileSystem(FileSystem):
    <span class="token tqs string">"""Adapter to make a filesystem read-only (at last, perfectly Pythonic)."""</span>

    <span class="token keyword">def</span> __init__(self, delegate):
        self._delegate = delegate

    <span class="token keyword">def</span> open(self, path, mode=<span class="token string">"r"</span>):
        <span class="token keyword">if</span> <span class="token logical keyword">not</span> mode.startswith(<span class="token string">"r"</span>):
            <span class="token keyword">raise</span> RuntimeError(<span class="token string">"Cannot open as %r: read-only filesystem"</span> % mode)
        <span class="token keyword">return</span> self._delegate.open(path, mode)

    <span class="token keyword">def</span> remove(self, path):
        <span class="token keyword">raise</span> RuntimeError(<span class="token string">"Cannot remove file: read-only filesystem"</span>)

    <span class="token keyword">for</span> method_name <span class="token keyword">in</span> FileSystem.__abstractmethods__:
        <span class="token keyword">if</span> method_name <span class="token keyword">in</span> locals():
            <span class="token keyword">continue</span>
        <span class="token keyword">def</span> make_delegator(m):  <span class="token comment"># indirection to close over `method_name`</span>
            <span class="token keyword">def</span> delegate(self, *args, **kwargs):
                <span class="token keyword">return</span> getattr(self._delegate, m)(*args, **kwargs)
            <span class="token keyword">return</span> delegate
        <span class="token comment"># This works in CPython 2.7 to at least 3.8.</span>
        locals()[method_name] = make_delegator(method_name)
        <span class="token keyword">del</span> make_delegator
        <span class="token keyword">del</span> method_name
</code></pre><p>If you’re still worrying about mutating <code class="_1ucarsym">locals()</code>, note that not only do <a href="https://github.com/python/cpython/blob/86c17c06c9420040c79c29ecf924741f37975342/Lib/xml/dom/xmlbuilder.py#L357" class="_16597jh">multiple places</a> in the <a href="https://github.com/python/cpython/blob/85e415108226cc5f3fdddd70196fc4c2a1d0f7f4/Lib/test/test_os.py#L1853" class="_16597jh">CPython standard library</a> do the same thing, but essentially this exact pattern is <a href="https://github.com/python/cpython/blob/85e415108226cc5f3fdddd70196fc4c2a1d0f7f4/Lib/test/test_scope.py#L443-L449" class="_16597jh">explicitly tested in CPython core</a>!</p><p>Let’s try it out:</p><pre class="_gy9i19"><code class="_1napz9l"><span class="token repl-marker prompt">>>> </span><span class="token keyword">import</span> main
<span class="token repl-marker prompt">>>> </span>fs = main.NativeFileSystem()
<span class="token repl-marker prompt">>>> </span><span class="token keyword">with</span> fs.open(<span class="token string">"foo"</span>, <span class="token string">"w"</span>) <span class="token keyword">as</span> outfile:
<span class="token repl-marker prompt">... </span>    outfile.write(<span class="token string">"hello\n"</span>)
<span class="token repl-marker prompt">... </span>
<span class="token repl-marker prompt">>>> </span>rofs = main.ReadOnlyFileSystem(fs)
<span class="token repl-marker prompt">>>> </span>rofs.listdir(<span class="token string">"."</span>)
<span class="token comment">['foo', 'main.py']</span>
<span class="token repl-marker prompt">>>> </span>len(rofs.open(<span class="token string">"foo"</span>).read())
<span class="token comment">6</span>
<span class="token repl-marker prompt">>>> </span>rofs.open(<span class="token string">"foo"</span>, <span class="token string">"w"</span>)
<span class="token comment">Traceback (most recent call last):</span>
<span class="token comment">  File "&lt;stdin>", line 1, in &lt;module></span>
<span class="token comment">  File "main.py", line 123, in open</span>
<span class="token comment">    raise RuntimeError("Cannot open as %r: read-only filesystem" % mode)</span>
<span class="token comment">RuntimeError: Cannot open as 'w': read-only filesystem</span>
</code></pre><p>Excellent! Everything’s working properly. It took executing non-trivial code inside a class definition, abusing <code class="_1ucarsym">locals()</code> in a way that’s explicitly discouraged, and some globals/closures kludgery, but we got there.</p><h2 class="_1htp0dj">Partial alternative: a custom metaclass</h2><p>At the start of this post, I claimed that this triply terrifying trick was the “<em>best</em> solution” that I know of. For comparison, let’s look at some other candidates. Here’s a solution along a different tack that does work, but has some other downsides.</p><p>This problem was borne upon us by the <code class="_1ucarsym">ABCMeta</code> metaclass. Perhaps a metaclass can fix it. After all, metaclasses get to directly inspect and modify the namespace object, which was our goal all along.</p><p>In the generic case, it turns out to be a bit tricky to determine which methods we should implement as delegates.<a href="https://github.com/python/cpython/blob/86c17c06c9420040c79c29ecf924741f37975342/Lib/abc.py#L133-L142" class="_16597jh">The way that <code class="_1ucarsym">ABCMeta</code> does it</a> requires first constructing the actual class object to defer to Python’s built-in <abbr title="method resolution order">MRO</abbr> logic. For example, <code class="_1ucarsym">ReadOnlyFileSystem.open</code> resolves to a function on the derived class, but <code class="_1ucarsym">ReadOnlyFileSystem.listdir</code> resolves to a function on the base class; the implementation of <code class="_1ucarsym">abc</code> takes advantage of the standard attribute resolution here. One simple approach, then, is to construct the class <em>twice</em>: once just to figure out which methods are abstract, and then again with a different namespace to resume the normal class creation process.</p><p>So let’s try our hand at writing an abstract base class metaclass with delegation support—an <code class="_1ucarsym">ABCDMeta</code>, if you will:</p><pre class="_gy9i19"><code class="_1napz9l"><span class="token keyword">class</span> ABCDMeta(abc.ABCMeta):
    <span class="token tqs string">"""Metaclass for abstract base classes with implicit delegation."""</span>

    <span class="token keyword">def</span> __new__(mcls, name, bases, attrs, **kwargs):
        <span class="token comment"># Take advantage of existing `__abstractmethods__` computation</span>
        <span class="token comment"># logic on `ABCMeta`.</span>
        cls = super(ABCDMeta, mcls).__new__(mcls, name, bases, attrs, **kwargs)
        abstracts = cls.__abstractmethods__
        <span class="token keyword">def</span> make_delegator(method_name):
            <span class="token keyword">def</span> delegator(self, *args, **kwargs):
                <span class="token keyword">return</span> getattr(self._delegate, method_name)(*args, **kwargs)
            <span class="token keyword">return</span> delegator
        <span class="token keyword">for</span> method_name <span class="token keyword">in</span> abstracts:
            <span class="token keyword">if</span> method_name <span class="token logical keyword">not</span> <span class="token keyword">in</span> attrs:
                attrs[method_name] = make_delegator(method_name)
        <span class="token keyword">return</span> super(ABCDMeta, mcls).__new__(mcls, name, bases, attrs, **kwargs)
</code></pre><p>Then, we could use this as the metaclass for <code class="_1ucarsym">ReadOnlyFileSystem</code>, defining only the two methods of interest. (It’s legal for the metaclass of a derived class to be a strict subtype of the metaclass for its ancestor classes.)</p><p>This appears to work in our simple example, but it’s not perfect. The fact that we’re creating the class twice is more than just inelegant: in some cases, it can lead to incorrect results. Some metaclasses perform side effects, like registering the new class in some global registry. For instance, <a href="https://github.com/django/django/blob/b0654fd6fafc28c3b0476cf2fa0d4eefe4162425/django/db/models/base.py#L316" class="_16597jh">Django’s <code class="_1ucarsym">ModelBase</code> does this</a>. A downstream user who attempted to use such a metaclass in conjunction with our <code class="_1ucarsym">ABCDMeta</code> by mixing them together (via multiple inheritance: <code class="_1ucarsym"><span class="token keyword">class</span> ABCDModelBase(ModelBase, ABCDMeta): <span class="token keyword">pass</span></code>) could see their models registered multiple times. Yet it also wouldn’t be correct to somehow “skip” applying the metaclasses on the first go-around, because then we might miss any implementations of the abstract methods provided by these metaclasses.</p><p>Of course, if we’re willing to make this a one-off metaclass that refers to <code class="_1ucarsym">FileSystem.__abstractmethods__</code> or the literal method names directly, then there’s no problem. But it’s not obvious how to turn this attempt into a correct <em>generic</em> solution.</p><p>This approach has another flaw. It is <a href="https://en.wikipedia.org/wiki/Anaphoric_macro" class="_16597jh">anaphoric</a>, not <a href="https://en.wikipedia.org/wiki/Hygienic_macro" class="_16597jh">hygienic</a>: there is an implicit contract between the metaclass and the derived class that the delegate is stored in a private attribute called <code class="_1ucarsym">_delegate</code>. This means that the metaclass is not compositional. For instance, it would not be possible to implement two different abstract classes with different delegate objects. Similarly, the delegate cannot be stored in a name-mangled variable (like <code class="_1ucarsym">__delegate</code>, with two underscores) by the derived class’s initializer without further hacks in the metaclass. Our previous solution didn’t disrupt name mangling, because the delegator methods were defined syntactically within the relevant class.</p><h2 class="_1htp0dj">Partial alternative: monkey-patch <code class="_1ucarsym">__abstractmethods__</code></h2><p>Finally, a different, simple approach merits a mention. The source of truth for the instantiation check is the <code class="_1ucarsym">__abstractmethods__</code> attribute on the type. So far, we’ve been trying to get that attribute to be an empty set organically. But, this being Python, we can just set the attribute directly:</p><pre class="_gy9i19"><code class="_1napz9l"><span class="token keyword">class</span> ReadOnlyFileSystem(FileSystem):
    <span class="token tqs string">"""Adapter to make a filesystem read-only (monkey-patching approach)."""</span>

    <span class="token keyword">def</span> __init__(self, delegate):
        self._delegate = delegate

    <span class="token keyword">def</span> open(self, path, mode=<span class="token string">"r"</span>):
        <span class="token keyword">if</span> <span class="token logical keyword">not</span> mode.startswith(<span class="token string">"r"</span>):
            <span class="token keyword">raise</span> RuntimeError(<span class="token string">"Cannot open as %r: read-only filesystem"</span> % mode)
        <span class="token keyword">return</span> self._delegate.open(path, mode)

    <span class="token keyword">def</span> remove(self, path):
        <span class="token keyword">raise</span> RuntimeError(<span class="token string">"Cannot remove file: read-only filesystem"</span>)


<span class="token keyword">def</span> make_delegator(method_name):
    <span class="token keyword">def</span> delegator(self, *args, **kwargs):
        <span class="token keyword">return</span> getattr(self._delegate, method_name)(*args, **kwargs)
    <span class="token keyword">return</span> delegator
<span class="token keyword">for</span> method_name <span class="token keyword">in</span> ReadOnlyFileSystem.__abstractmethods__:
    setattr(ReadOnlyFileSystem, method_name, make_delegator(method_name))
<span class="token comment"># No longer abstract! We implemented them. :-)</span>
ReadOnlyFileSystem.__abstractmethods__ = frozenset()
</code></pre><p>This looks good! It’s simple, it requires comparatively few hacks, and it kind of makes semantic sense. On top of all that, it’s even almost correct. But it’s not, in general: not quite. The CPython internals have <a href="https://github.com/python/cpython/blob/952899704800a5aa438e84d50f0b6fc498c72e89/Objects/typeobject.c#L584-L587" class="_16597jh">a comment in <code class="_1ucarsym">type_set_abstractmethods</code></a>:</p><blockquote><code class="_1ucarsym">__abstractmethods__</code> should only be set once on a type, in <code class="_1ucarsym">abc.ABCMeta.__new__</code>, so this function doesn&#x27;t do anything special to update subclasses.</blockquote><p>So, okay, we’re apparently violating an undocumented invariant of CPython. At first blush, this seems irrelevant: it sure doesn’t look like we’re creating any subclasses before we set <code class="_1ucarsym">__abstractmethods__</code>. But we can’t even rely on that in general, because one of the parent metaclasses could have already created subclasses as soon as the original class was created, and the <code class="_1ucarsym">__abstractmethods__</code> attributes on those subclasses will not have taken our changes into account.</p><p>Like the custom metaclass approach, this solution also breaks name mangling, which is unfortunate.</p><h2 class="_1htp0dj">Conclusion</h2><p>Coming back to reality, it goes without saying that there is only one good solution in this post, and that it is the first one presented: the one with explicit delegation.</p><p>Python offers a lot of tempting dynamism. You really can put a <code class="_1ucarsym"><span class="token keyword">for</span></code>-loop in a class definition, and it will basically “just work”. But as soon as we have to start reasoning about multiple metaclass inheritance or CPython implementation details just to implement a simple interface, we should know that we’ve taken it too far. All these extra arms of the dynamic octopus compound with each other to make it exceedingly difficult to build robust abstractions.</p><p>Taking the straightforward implementation that would be natural in, say, Java or OCaml can often lead to a clear, readable, maintainable solution. Sometimes it turns out boring—and boring is just fine.</p></article><a style="margin-bottom:10px;margin-top:10px" class="_16597jh" href="/posts"><i>« back to posts</i></a></div></article><footer class="_1gtwn3"><div class="_1yyogy7"><a href="https://github.com/wchargin" class="_16597jh"><svg width="16" height="16" style="vertical-align:middle" viewBox="0 0 16 16" alt="GitHub" aria-label="GitHub"><path fill="currentColor" d="m8 0.431c-4.28 0-7.76 3.47-7.76 7.76 0 3.43 2.22 6.34 5.31 7.36 0.388 0.071 0.53-0.168 0.53-0.374 0-0.184-0.007-0.672-0.01-1.32-2.16 0.469-2.61-1.04-2.61-1.04-0.353-0.896-0.862-1.14-0.862-1.14-0.705-0.481 0.053-0.472 0.053-0.472 0.779 0.055 1.19 0.8 1.19 0.8 0.692 1.19 1.82 0.843 2.26 0.645 0.071-0.502 0.271-0.843 0.493-1.04-1.73-0.3-3.54-0.9-3.54-3.91 0-0.847 0.302-1.54 0.799-2.08-0.08-0.2-0.35-0.99 0.07-2.06 0 0 0.652-0.209 2.13 0.796 0.63-0.18 1.29-0.26 1.95-0.27 0.659 0.003 1.32 0.089 1.94 0.261 1.48-1 2.13-0.796 2.13-0.796 0.423 1.07 0.157 1.86 0.077 2.05 0.497 0.542 0.798 1.24 0.798 2.08 0 2.98-1.81 3.64-3.54 3.83 0.279 0.24 0.527 0.713 0.527 1.44 0 1.04-0.01 1.87-0.01 2.13 0 0.208 0.14 0.449 0.534 0.373 3.08-1.03 5.3-3.94 5.3-7.36 0-4.23-3.5-7.71-7.8-7.71z"></path></svg> wchargin</a><br/><span>email me @gmail.com</span></div></footer></div></div>
</body>
</html>
